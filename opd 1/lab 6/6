ORG 0x0	
V0: WORD $DEFAULT, 0x180	; инициализация векторов прерывания
V1: WORD $INT1, 0x180	
V2: WORD $INT2, 0x180	
V3: WORD $DEFAULT, 0x180	
V4: WORD $DEFAULT, 0x180	
V5: WORD $DEFAULT, 0x180	
V6: WORD $DEFAULT, 0x180	
V7: WORD $DEFAULT, 0x180	
	
DEFAULT: IRET	; возврат
	
ORG 0x1C	
X: WORD 0x0000	; по умолчанию X равен максимуму
MAX: WORD 0x002A	; максимальное по ОДЗ значение X
MIN: WORD 0xFFD5	; минимальное по ОДЗ значение X
k: WORD 0x00FF	; переменная для обнуления старшего байта X
	
ORG 0x20	
START: DI 	; запрещаем прерывания
CLA 	; обнуляем аккумулятор
OUT 1 	; MR КВУ-0 на вектор 0 
OUT 7
OUT 0xB
OUT 0xE
OUT 0x12
OUT 0x16
OUT 0x1A
OUT 0x1E
LD #9	; разрешаем прерывания и MR КВУ-1 на вектор 1
OUT 3	
LD #0xA	; разрешаем прерывания и MR КВУ-2 на вектор 2
OUT 5	
JUMP $PROG	
	
ORG 0x30	
PROG: EI	; разрешаем прерывания
INCLP: DI	; запрещаем прерывания для атомарности операции
LD X 	; декрементируем X
DEC	
ST X	
CALL CHECK	; проверяем X на нахождение в ОДЗ
EI	; обратно разрешаем прерывания
JUMP INCLP 	
	
CHECK: CMP MIN	; сравниваем X с минимумом
BGE EXIT	; не выходит за границу – возвращаемся в основную программу
HLT	; исследуем значение X в момент его выхода за пределы ОДЗ
LD MAX	; загружаем максимум в X
ST X	
HLT	; исследуем правильность записи в X максимального по ОДЗ значения
EXIT: RET	
	
	
ORG 0x40	
INT1: 	; обработчик прерывания по вектору 1
LD X 	; загрузили X в аккумулятор
HLT	; исследуем значение X в момент возникновения прерывания
ASL 	; AC = 2X
ADD X 	; AC = 3X
NEG 	; AC = -3X
SUB #0x02	; AC = -3X - 2   
OUT 2 	; записываем AC в DR ВУ1
HLT	; исследуем правильность подсчёта функции и вывода результата на ВУ-1
IRET	; возврат из обработчика
	
ORG 0x50	
INT2:	; обработчик прерывания по вектору 2
LD X 	; загрузили X в аккумулятор
HLT 	; исследуем значение X в момент возникновения прерывания
IN 4 	; записываем DR ВУ-2 в AC
OR X 	; побитовое ИЛИ с X
ST X 	; сохраняем X
HLT	; исследуем правильность подсчёта 
IRET 	; возврат из обработчика
