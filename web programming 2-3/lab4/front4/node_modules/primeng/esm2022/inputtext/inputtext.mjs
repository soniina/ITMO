import { booleanAttribute, Directive, HostListener, inject, Input, NgModule, Optional } from '@angular/core';
import { isEmpty } from '@primeuix/utils';
import { BaseComponent } from 'primeng/basecomponent';
import { InputTextStyle } from './style/inputtextstyle';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
/**
 * InputText directive is an extension to standard input element with theming.
 * @group Components
 */
export class InputText extends BaseComponent {
    ngModel;
    /**
     * Specifies the input variant of the component.
     * @group Props
     */
    variant = 'outlined';
    /**
     * Spans 100% width of the container when enabled.
     * @group Props
     */
    fluid;
    /**
     * Defines the size of the component.
     * @group Props
     */
    pSize;
    filled;
    _componentStyle = inject(InputTextStyle);
    get hasFluid() {
        const nativeElement = this.el.nativeElement;
        const fluidComponent = nativeElement.closest('p-fluid');
        return isEmpty(this.fluid) ? !!fluidComponent : this.fluid;
    }
    constructor(ngModel) {
        super();
        this.ngModel = ngModel;
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.updateFilledState();
        this.cd.detectChanges();
    }
    ngDoCheck() {
        this.updateFilledState();
    }
    onInput() {
        this.updateFilledState();
    }
    updateFilledState() {
        this.filled = (this.el.nativeElement.value && this.el.nativeElement.value.length) || (this.ngModel && this.ngModel.model);
    }
    static ɵfac = function InputText_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || InputText)(i0.ɵɵdirectiveInject(i1.NgModel, 8)); };
    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: InputText, selectors: [["", "pInputText", ""]], hostAttrs: [1, "p-inputtext", "p-component"], hostVars: 14, hostBindings: function InputText_HostBindings(rf, ctx) { if (rf & 1) {
            i0.ɵɵlistener("input", function InputText_input_HostBindingHandler($event) { return ctx.onInput($event); });
        } if (rf & 2) {
            i0.ɵɵclassProp("p-filled", ctx.filled)("p-variant-filled", ctx.variant === "filled" || ctx.config.inputStyle() === "filled" || ctx.config.inputVariant() === "filled")("p-inputtext-fluid", ctx.hasFluid)("p-inputtext-sm", ctx.pSize === "small")("p-inputfield-sm", ctx.pSize === "small")("p-inputtext-lg", ctx.pSize === "large")("p-inputfield-lg", ctx.pSize === "large");
        } }, inputs: { variant: "variant", fluid: [2, "fluid", "fluid", booleanAttribute], pSize: "pSize" }, standalone: true, features: [i0.ɵɵProvidersFeature([InputTextStyle]), i0.ɵɵInputTransformsFeature, i0.ɵɵInheritDefinitionFeature] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(InputText, [{
        type: Directive,
        args: [{
                selector: '[pInputText]',
                standalone: true,
                host: {
                    class: 'p-inputtext p-component',
                    '[class.p-filled]': 'filled',
                    '[class.p-variant-filled]': 'variant === "filled" || config.inputStyle() === "filled" || config.inputVariant() === "filled"',
                    '[class.p-inputtext-fluid]': 'hasFluid',
                    '[class.p-inputtext-sm]': 'pSize === "small"',
                    '[class.p-inputfield-sm]': 'pSize === "small"',
                    '[class.p-inputtext-lg]': 'pSize === "large"',
                    '[class.p-inputfield-lg]': 'pSize === "large"'
                },
                providers: [InputTextStyle]
            }]
    }], () => [{ type: i1.NgModel, decorators: [{
                type: Optional
            }] }], { variant: [{
            type: Input
        }], fluid: [{
            type: Input,
            args: [{ transform: booleanAttribute }]
        }], pSize: [{
            type: Input,
            args: ['pSize']
        }], onInput: [{
            type: HostListener,
            args: ['input', ['$event']]
        }] }); })();
export class InputTextModule {
    static ɵfac = function InputTextModule_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || InputTextModule)(); };
    static ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: InputTextModule });
    static ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({});
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(InputTextModule, [{
        type: NgModule,
        args: [{
                imports: [InputText],
                exports: [InputText]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(InputTextModule, { imports: [InputText], exports: [InputText] }); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXR0ZXh0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2lucHV0dGV4dC9pbnB1dHRleHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFpQixnQkFBZ0IsRUFBRSxTQUFTLEVBQVcsWUFBWSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVySSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDMUMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRXRELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQzs7O0FBRXhEOzs7R0FHRztBQWdCSCxNQUFNLE9BQU8sU0FBVSxTQUFRLGFBQWE7SUE0QlQ7SUEzQi9COzs7T0FHRztJQUNNLE9BQU8sR0FBMEIsVUFBVSxDQUFDO0lBQ3JEOzs7T0FHRztJQUNxQyxLQUFLLENBQXNCO0lBQ25FOzs7T0FHRztJQUNhLEtBQUssQ0FBb0I7SUFFekMsTUFBTSxDQUFvQjtJQUUxQixlQUFlLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBRXpDLElBQUksUUFBUTtRQUNSLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDO1FBQzVDLE1BQU0sY0FBYyxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFeEQsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQy9ELENBQUM7SUFFRCxZQUErQixPQUFnQjtRQUMzQyxLQUFLLEVBQUUsQ0FBQztRQURtQixZQUFPLEdBQVAsT0FBTyxDQUFTO0lBRS9DLENBQUM7SUFFRCxlQUFlO1FBQ1gsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDNUIsQ0FBQztJQUVELFNBQVM7UUFDTCxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBR0QsT0FBTztRQUNILElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFFRCxpQkFBaUI7UUFDYixJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM5SCxDQUFDO21HQWpEUSxTQUFTOzZEQUFULFNBQVM7WUFBVCxvRkFBQSxtQkFBZSxJQUFOOztZQUFULHNDQUFTLHFDQUFHLFFBQVEsSUFBSSx1QkFBbUIsS0FBSyxRQUFRLElBQUkseUJBRXBFLEtBQUssUUFBUSxDQUZJLG1DQUFBLGlDQUFDLE9BQU8sQ0FBUixrQ0FBQyxPQUFPLENBQVIsaUNBQUMsT0FBTyxDQUFSLGtDQUFDLE9BQU8sQ0FBUjt3RUFVRSxnQkFBZ0Isd0VBWnpCLENBQUMsY0FBYyxDQUFDOztpRkFFbEIsU0FBUztjQWZyQixTQUFTO2VBQUM7Z0JBQ1AsUUFBUSxFQUFFLGNBQWM7Z0JBQ3hCLFVBQVUsRUFBRSxJQUFJO2dCQUNoQixJQUFJLEVBQUU7b0JBQ0YsS0FBSyxFQUFFLHlCQUF5QjtvQkFDaEMsa0JBQWtCLEVBQUUsUUFBUTtvQkFDNUIsMEJBQTBCLEVBQUUsZ0dBQWdHO29CQUM1SCwyQkFBMkIsRUFBRSxVQUFVO29CQUN2Qyx3QkFBd0IsRUFBRSxtQkFBbUI7b0JBQzdDLHlCQUF5QixFQUFFLG1CQUFtQjtvQkFDOUMsd0JBQXdCLEVBQUUsbUJBQW1CO29CQUM3Qyx5QkFBeUIsRUFBRSxtQkFBbUI7aUJBQ2pEO2dCQUNELFNBQVMsRUFBRSxDQUFDLGNBQWMsQ0FBQzthQUM5Qjs7c0JBNkJnQixRQUFRO3FCQXZCWixPQUFPO2tCQUFmLEtBQUs7WUFLa0MsS0FBSztrQkFBNUMsS0FBSzttQkFBQyxFQUFFLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRTtZQUt0QixLQUFLO2tCQUFwQixLQUFLO21CQUFDLE9BQU87WUE0QmQsT0FBTztrQkFETixZQUFZO21CQUFDLE9BQU8sRUFBRSxDQUFDLFFBQVEsQ0FBQzs7QUFjckMsTUFBTSxPQUFPLGVBQWU7eUdBQWYsZUFBZTs0REFBZixlQUFlOzs7aUZBQWYsZUFBZTtjQUozQixRQUFRO2VBQUM7Z0JBQ04sT0FBTyxFQUFFLENBQUMsU0FBUyxDQUFDO2dCQUNwQixPQUFPLEVBQUUsQ0FBQyxTQUFTLENBQUM7YUFDdkI7O3dGQUNZLGVBQWUsY0F4RGYsU0FBUyxhQUFULFNBQVMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBib29sZWFuQXR0cmlidXRlLCBEaXJlY3RpdmUsIERvQ2hlY2ssIEhvc3RMaXN0ZW5lciwgaW5qZWN0LCBJbnB1dCwgTmdNb2R1bGUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ01vZGVsIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgaXNFbXB0eSB9IGZyb20gJ0BwcmltZXVpeC91dGlscyc7XG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAncHJpbWVuZy9iYXNlY29tcG9uZW50JztcbmltcG9ydCB7IE51bGxhYmxlIH0gZnJvbSAncHJpbWVuZy90cy1oZWxwZXJzJztcbmltcG9ydCB7IElucHV0VGV4dFN0eWxlIH0gZnJvbSAnLi9zdHlsZS9pbnB1dHRleHRzdHlsZSc7XG5cbi8qKlxuICogSW5wdXRUZXh0IGRpcmVjdGl2ZSBpcyBhbiBleHRlbnNpb24gdG8gc3RhbmRhcmQgaW5wdXQgZWxlbWVudCB3aXRoIHRoZW1pbmcuXG4gKiBAZ3JvdXAgQ29tcG9uZW50c1xuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1twSW5wdXRUZXh0XScsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBob3N0OiB7XG4gICAgICAgIGNsYXNzOiAncC1pbnB1dHRleHQgcC1jb21wb25lbnQnLFxuICAgICAgICAnW2NsYXNzLnAtZmlsbGVkXSc6ICdmaWxsZWQnLFxuICAgICAgICAnW2NsYXNzLnAtdmFyaWFudC1maWxsZWRdJzogJ3ZhcmlhbnQgPT09IFwiZmlsbGVkXCIgfHwgY29uZmlnLmlucHV0U3R5bGUoKSA9PT0gXCJmaWxsZWRcIiB8fCBjb25maWcuaW5wdXRWYXJpYW50KCkgPT09IFwiZmlsbGVkXCInLFxuICAgICAgICAnW2NsYXNzLnAtaW5wdXR0ZXh0LWZsdWlkXSc6ICdoYXNGbHVpZCcsXG4gICAgICAgICdbY2xhc3MucC1pbnB1dHRleHQtc21dJzogJ3BTaXplID09PSBcInNtYWxsXCInLFxuICAgICAgICAnW2NsYXNzLnAtaW5wdXRmaWVsZC1zbV0nOiAncFNpemUgPT09IFwic21hbGxcIicsXG4gICAgICAgICdbY2xhc3MucC1pbnB1dHRleHQtbGddJzogJ3BTaXplID09PSBcImxhcmdlXCInLFxuICAgICAgICAnW2NsYXNzLnAtaW5wdXRmaWVsZC1sZ10nOiAncFNpemUgPT09IFwibGFyZ2VcIidcbiAgICB9LFxuICAgIHByb3ZpZGVyczogW0lucHV0VGV4dFN0eWxlXVxufSlcbmV4cG9ydCBjbGFzcyBJbnB1dFRleHQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgRG9DaGVjaywgQWZ0ZXJWaWV3SW5pdCB7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBpbnB1dCB2YXJpYW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KCkgdmFyaWFudDogJ2ZpbGxlZCcgfCAnb3V0bGluZWQnID0gJ291dGxpbmVkJztcbiAgICAvKipcbiAgICAgKiBTcGFucyAxMDAlIHdpZHRoIG9mIHRoZSBjb250YWluZXIgd2hlbiBlbmFibGVkLlxuICAgICAqIEBncm91cCBQcm9wc1xuICAgICAqL1xuICAgIEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KSBmbHVpZDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBzaXplIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KCdwU2l6ZScpIHBTaXplOiAnbGFyZ2UnIHwgJ3NtYWxsJztcblxuICAgIGZpbGxlZDogTnVsbGFibGU8Ym9vbGVhbj47XG5cbiAgICBfY29tcG9uZW50U3R5bGUgPSBpbmplY3QoSW5wdXRUZXh0U3R5bGUpO1xuXG4gICAgZ2V0IGhhc0ZsdWlkKCkge1xuICAgICAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBmbHVpZENvbXBvbmVudCA9IG5hdGl2ZUVsZW1lbnQuY2xvc2VzdCgncC1mbHVpZCcpO1xuXG4gICAgICAgIHJldHVybiBpc0VtcHR5KHRoaXMuZmx1aWQpID8gISFmbHVpZENvbXBvbmVudCA6IHRoaXMuZmx1aWQ7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHVibGljIG5nTW9kZWw6IE5nTW9kZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nQWZ0ZXJWaWV3SW5pdCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbGxlZFN0YXRlKCk7XG4gICAgICAgIHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgdGhpcy51cGRhdGVGaWxsZWRTdGF0ZSgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2lucHV0JywgWyckZXZlbnQnXSlcbiAgICBvbklucHV0KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbGxlZFN0YXRlKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlRmlsbGVkU3RhdGUoKSB7XG4gICAgICAgIHRoaXMuZmlsbGVkID0gKHRoaXMuZWwubmF0aXZlRWxlbWVudC52YWx1ZSAmJiB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQudmFsdWUubGVuZ3RoKSB8fCAodGhpcy5uZ01vZGVsICYmIHRoaXMubmdNb2RlbC5tb2RlbCk7XG4gICAgfVxufVxuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtJbnB1dFRleHRdLFxuICAgIGV4cG9ydHM6IFtJbnB1dFRleHRdXG59KVxuZXhwb3J0IGNsYXNzIElucHV0VGV4dE1vZHVsZSB7fVxuIl19