import { CommonModule } from '@angular/common';
import { booleanAttribute, ChangeDetectionStrategy, Component, ContentChild, EventEmitter, forwardRef, HostBinding, inject, Input, NgModule, numberAttribute, Output } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { SharedModule } from 'primeng/api';
import { AutoFocus } from 'primeng/autofocus';
import { BaseComponent } from 'primeng/basecomponent';
import { Ripple } from 'primeng/ripple';
import { ToggleButtonStyle } from './style/togglebuttonstyle';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
const _c0 = ["icon"];
const _c1 = ["content"];
const _c2 = a0 => ({ $implicit: a0 });
const _c3 = (a0, a1) => ({ "p-togglebutton-icon": true, "p-togglebutton-icon-left": a0, "p-togglebutton-icon-right": a1 });
function ToggleButton_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ToggleButton_Conditional_3_Conditional_0_Conditional_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 1);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(3);
    i0.ɵɵclassMap(ctx_r0.checked ? ctx_r0.onIcon : ctx_r0.offIcon);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(4, _c3, ctx_r0.iconPos === "left", ctx_r0.iconPos === "right"));
    i0.ɵɵattribute("data-pc-section", "icon");
} }
function ToggleButton_Conditional_3_Conditional_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, ToggleButton_Conditional_3_Conditional_0_Conditional_0_Template, 1, 7, "span", 3);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵconditional(ctx_r0.onIcon || ctx_r0.offIcon ? 0 : -1);
} }
function ToggleButton_Conditional_3_Conditional_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ToggleButton_Conditional_3_Conditional_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, ToggleButton_Conditional_3_Conditional_1_ng_container_0_Template, 1, 0, "ng-container", 2);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r0.iconTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c2, ctx_r0.checked));
} }
function ToggleButton_Conditional_3_Conditional_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 1);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("ngClass", ctx_r0.cx("label"));
    i0.ɵɵattribute("data-pc-section", "label");
    i0.ɵɵadvance();
    i0.ɵɵtextInterpolate(ctx_r0.checked ? ctx_r0.hasOnLabel ? ctx_r0.onLabel : "" : ctx_r0.hasOffLabel ? ctx_r0.offLabel : "");
} }
function ToggleButton_Conditional_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, ToggleButton_Conditional_3_Conditional_0_Template, 1, 1)(1, ToggleButton_Conditional_3_Conditional_1_Template, 1, 4, "ng-container")(2, ToggleButton_Conditional_3_Conditional_2_Template, 2, 3, "span", 1);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵconditional(!ctx_r0.iconTemplate ? 0 : 1);
    i0.ɵɵadvance(2);
    i0.ɵɵconditional(ctx_r0.onLabel || ctx_r0.offLabel ? 2 : -1);
} }
export const TOGGLEBUTTON_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => ToggleButton),
    multi: true
};
/**
 * ToggleButton is used to select a boolean value using a button.
 * @group Components
 */
export class ToggleButton extends BaseComponent {
    /**
     * Label for the on state.
     * @group Props
     */
    onLabel = 'Yes';
    /**
     * Label for the off state.
     * @group Props
     */
    offLabel = 'No';
    /**
     * Icon for the on state.
     * @group Props
     */
    onIcon;
    /**
     * Icon for the off state.
     * @group Props
     */
    offIcon;
    /**
     * Defines a string that labels the input for accessibility.
     * @group Props
     */
    ariaLabel;
    /**
     * Establishes relationships between the component and label(s) where its value should be one or more element IDs.
     * @group Props
     */
    ariaLabelledBy;
    /**
     * When present, it specifies that the element should be disabled.
     * @group Props
     */
    disabled;
    /**
     * Inline style of the element.
     * @group Props
     */
    style;
    /**
     * Style class of the element.
     * @group Props
     */
    styleClass;
    get hostClass() {
        return this.styleClass || '';
    }
    /**
     * Identifier of the focus input to match a label defined for the component.
     * @group Props
     */
    inputId;
    /**
     * Index of the element in tabbing order.
     * @group Props
     */
    tabindex = 0;
    /**
     * Defines the size of the component.
     * @group Props
     */
    size;
    /**
     * Position of the icon.
     * @group Props
     */
    iconPos = 'left';
    /**
     * When present, it specifies that the component should automatically get focus on load.
     * @group Props
     */
    autofocus;
    /**
     * Whether selection can not be cleared.
     * @group Props
     */
    allowEmpty;
    /**
     * Callback to invoke on value change.
     * @param {ToggleButtonChangeEvent} event - Custom change event.
     * @group Emits
     */
    onChange = new EventEmitter();
    /**
     * Custom icon template.
     * @group Templates
     */
    iconTemplate;
    /**
     * Custom content template.
     * @group Templates
     */
    contentTemplate;
    checked = false;
    onModelChange = () => { };
    onModelTouched = () => { };
    _componentStyle = inject(ToggleButtonStyle);
    toggle(event) {
        if (!this.disabled && !(this.allowEmpty === false && this.checked)) {
            this.checked = !this.checked;
            this.onModelChange(this.checked);
            this.onModelTouched();
            this.onChange.emit({
                originalEvent: event,
                checked: this.checked
            });
            this.cd.markForCheck();
        }
    }
    onKeyDown(event) {
        switch (event.code) {
            case 'Enter':
                this.toggle(event);
                event.preventDefault();
                break;
            case 'Space':
                this.toggle(event);
                event.preventDefault();
                break;
        }
    }
    onBlur() {
        this.onModelTouched();
    }
    writeValue(value) {
        this.checked = value;
        this.cd.markForCheck();
    }
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
    setDisabledState(val) {
        this.disabled = val;
        this.cd.markForCheck();
    }
    get hasOnLabel() {
        return (this.onLabel && this.onLabel.length > 0);
    }
    get hasOffLabel() {
        return (this.onLabel && this.onLabel.length > 0);
    }
    get active() {
        return this.checked === true;
    }
    static ɵfac = /*@__PURE__*/ (() => { let ɵToggleButton_BaseFactory; return function ToggleButton_Factory(__ngFactoryType__) { return (ɵToggleButton_BaseFactory || (ɵToggleButton_BaseFactory = i0.ɵɵgetInheritedFactory(ToggleButton)))(__ngFactoryType__ || ToggleButton); }; })();
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ToggleButton, selectors: [["p-toggleButton"], ["p-togglebutton"], ["p-toggle-button"]], contentQueries: function ToggleButton_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
            i0.ɵɵcontentQuery(dirIndex, _c0, 5);
            i0.ɵɵcontentQuery(dirIndex, _c1, 5);
        } if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.iconTemplate = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
        } }, hostVars: 2, hostBindings: function ToggleButton_HostBindings(rf, ctx) { if (rf & 2) {
            i0.ɵɵclassMap(ctx.hostClass);
        } }, inputs: { onLabel: "onLabel", offLabel: "offLabel", onIcon: "onIcon", offIcon: "offIcon", ariaLabel: "ariaLabel", ariaLabelledBy: "ariaLabelledBy", disabled: [2, "disabled", "disabled", booleanAttribute], style: "style", styleClass: "styleClass", inputId: "inputId", tabindex: [2, "tabindex", "tabindex", numberAttribute], size: "size", iconPos: "iconPos", autofocus: [2, "autofocus", "autofocus", booleanAttribute], allowEmpty: "allowEmpty" }, outputs: { onChange: "onChange" }, standalone: true, features: [i0.ɵɵProvidersFeature([TOGGLEBUTTON_VALUE_ACCESSOR, ToggleButtonStyle]), i0.ɵɵInputTransformsFeature, i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature], decls: 4, vars: 15, consts: [["pRipple", "", "type", "button", 3, "click", "ngClass", "tabindex", "disabled"], [3, "ngClass"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "class", "ngClass"]], template: function ToggleButton_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵelementStart(0, "button", 0);
            i0.ɵɵlistener("click", function ToggleButton_Template_button_click_0_listener($event) { return ctx.toggle($event); });
            i0.ɵɵelementStart(1, "span", 1);
            i0.ɵɵtemplate(2, ToggleButton_ng_container_2_Template, 1, 0, "ng-container", 2)(3, ToggleButton_Conditional_3_Template, 3, 2);
            i0.ɵɵelementEnd()();
        } if (rf & 2) {
            i0.ɵɵclassMap(ctx.styleClass);
            i0.ɵɵproperty("ngClass", ctx.cx("root"))("tabindex", ctx.tabindex)("disabled", ctx.disabled);
            i0.ɵɵattribute("aria-labelledby", ctx.ariaLabelledBy)("aria-pressed", ctx.checked)("data-p-checked", ctx.active)("data-p-disabled", ctx.disabled);
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngClass", ctx.cx("content"));
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngTemplateOutlet", ctx.contentTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(13, _c2, ctx.checked));
            i0.ɵɵadvance();
            i0.ɵɵconditional(!ctx.contentTemplate ? 3 : -1);
        } }, dependencies: [Ripple, CommonModule, i1.NgClass, i1.NgTemplateOutlet, SharedModule], encapsulation: 2, changeDetection: 0 });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ToggleButton, [{
        type: Component,
        args: [{
                selector: 'p-toggleButton, p-togglebutton, p-toggle-button',
                standalone: true,
                imports: [Ripple, AutoFocus, CommonModule, SharedModule],
                template: `
        <button
            pRipple
            type="button"
            [ngClass]="cx('root')"
            [class]="styleClass"
            [tabindex]="tabindex"
            [disabled]="disabled"
            (click)="toggle($event)"
            [attr.aria-labelledby]="ariaLabelledBy"
            [attr.aria-pressed]="checked"
            [attr.data-p-checked]="active"
            [attr.data-p-disabled]="disabled"
        >
            <span [ngClass]="cx('content')">
                <ng-container *ngTemplateOutlet="contentTemplate; context: { $implicit: checked }"></ng-container>
                @if (!contentTemplate) {
                    @if (!iconTemplate) {
                        @if (onIcon || offIcon) {
                            <span
                                [class]="checked ? this.onIcon : this.offIcon"
                                [ngClass]="{
                                    'p-togglebutton-icon': true,
                                    'p-togglebutton-icon-left': iconPos === 'left',
                                    'p-togglebutton-icon-right': iconPos === 'right'
                                }"
                                [attr.data-pc-section]="'icon'"
                            ></span>
                        }
                    } @else {
                        <ng-container *ngTemplateOutlet="iconTemplate; context: { $implicit: checked }"></ng-container>
                    }
                    @if (onLabel || offLabel) {
                        <span [ngClass]="cx('label')" [attr.data-pc-section]="'label'">{{ checked ? (hasOnLabel ? onLabel : '') : hasOffLabel ? offLabel : '' }}</span>
                    }
                }
            </span>
        </button>
    `,
                providers: [TOGGLEBUTTON_VALUE_ACCESSOR, ToggleButtonStyle],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { onLabel: [{
            type: Input
        }], offLabel: [{
            type: Input
        }], onIcon: [{
            type: Input
        }], offIcon: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], ariaLabelledBy: [{
            type: Input
        }], disabled: [{
            type: Input,
            args: [{ transform: booleanAttribute }]
        }], style: [{
            type: Input
        }], styleClass: [{
            type: Input
        }], hostClass: [{
            type: HostBinding,
            args: ['class']
        }], inputId: [{
            type: Input
        }], tabindex: [{
            type: Input,
            args: [{ transform: numberAttribute }]
        }], size: [{
            type: Input
        }], iconPos: [{
            type: Input
        }], autofocus: [{
            type: Input,
            args: [{ transform: booleanAttribute }]
        }], allowEmpty: [{
            type: Input
        }], onChange: [{
            type: Output
        }], iconTemplate: [{
            type: ContentChild,
            args: ['icon']
        }], contentTemplate: [{
            type: ContentChild,
            args: ['content']
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(ToggleButton, { className: "ToggleButton" }); })();
export class ToggleButtonModule {
    static ɵfac = function ToggleButtonModule_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || ToggleButtonModule)(); };
    static ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: ToggleButtonModule });
    static ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [ToggleButton, SharedModule, SharedModule] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ToggleButtonModule, [{
        type: NgModule,
        args: [{
                imports: [ToggleButton, SharedModule],
                exports: [ToggleButton, SharedModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(ToggleButtonModule, { imports: [ToggleButton, SharedModule], exports: [ToggleButton, SharedModule] }); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlYnV0dG9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3RvZ2dsZWJ1dHRvbi90b2dnbGVidXR0b24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLGVBQWUsRUFBRSxNQUFNLEVBQWUsTUFBTSxlQUFlLENBQUM7QUFDek0sT0FBTyxFQUF3QixpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDM0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQzlDLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFeEMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7Ozs7Ozs7O0lBK0I5Qyx3QkFBa0c7OztJQUl0RiwwQkFRUTs7O0lBUEosOERBQThDO0lBQzlDLDJHQUlFOzs7O0lBUFYsa0dBQXlCOzs7SUFBekIsMERBVUM7OztJQUVELHdCQUErRjs7O0lBQS9GLDJHQUFnRjs7O0lBQWpDLEFBQWhDLHNEQUFnQyx1RUFBK0I7OztJQUc5RSwrQkFBK0Q7SUFBQSxZQUF5RTtJQUFBLGlCQUFPOzs7SUFBekksNENBQXVCOztJQUFrQyxjQUF5RTtJQUF6RSwwSEFBeUU7OztJQUQ1SSxBQUhFLEFBWkYseUVBQXFCLDRFQVlaLHVFQUdrQjs7O0lBZjNCLDhDQWNDO0lBQ0QsZUFFQztJQUZELDREQUVDOztBQS9DckIsTUFB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QVk7QUEwS3pCLE1BQU0sT0FBTyxrQkFBa0I7NEdBQWxCLGtCQUFrQjs0REFBbEIsa0JBQWtCO2dFQUhqQixZQUFZLEVBQUUsWUFBWSxFQUNaLFlBQVk7O2lGQUUzQixrQkFBa0I7Y0FKOUIsUUFBUTtlQUFDO2dCQUNOLE9BQU8sRUFBRSxDQUFDLFlBQVksRUFBRSxZQUFZLENBQUM7Z0JBQ3JDLE9BQU8sRUFBRSxDQUFDLFlBQVksRUFBRSxZQUFZLENBQUM7YUFDeEM7O3dGQUNZLGtCQUFrQixjQTFLbEIsWUFBWSxFQXVLRyxZQUFZLGFBdkszQixZQUFZLEVBd0tHLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgYm9vbGVhbkF0dHJpYnV0ZSwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgQ29udGVudENoaWxkLCBFdmVudEVtaXR0ZXIsIGZvcndhcmRSZWYsIEhvc3RCaW5kaW5nLCBpbmplY3QsIElucHV0LCBOZ01vZHVsZSwgbnVtYmVyQXR0cmlidXRlLCBPdXRwdXQsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTaGFyZWRNb2R1bGUgfSBmcm9tICdwcmltZW5nL2FwaSc7XG5pbXBvcnQgeyBBdXRvRm9jdXMgfSBmcm9tICdwcmltZW5nL2F1dG9mb2N1cyc7XG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAncHJpbWVuZy9iYXNlY29tcG9uZW50JztcbmltcG9ydCB7IFJpcHBsZSB9IGZyb20gJ3ByaW1lbmcvcmlwcGxlJztcbmltcG9ydCB7IE51bGxhYmxlIH0gZnJvbSAncHJpbWVuZy90cy1oZWxwZXJzJztcbmltcG9ydCB7IFRvZ2dsZUJ1dHRvblN0eWxlIH0gZnJvbSAnLi9zdHlsZS90b2dnbGVidXR0b25zdHlsZSc7XG5pbXBvcnQgeyBUb2dnbGVCdXR0b25DaGFuZ2VFdmVudCB9IGZyb20gJy4vdG9nZ2xlYnV0dG9uLmludGVyZmFjZSc7XG5cbmV4cG9ydCBjb25zdCBUT0dHTEVCVVRUT05fVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUb2dnbGVCdXR0b24pLFxuICAgIG11bHRpOiB0cnVlXG59O1xuLyoqXG4gKiBUb2dnbGVCdXR0b24gaXMgdXNlZCB0byBzZWxlY3QgYSBib29sZWFuIHZhbHVlIHVzaW5nIGEgYnV0dG9uLlxuICogQGdyb3VwIENvbXBvbmVudHNcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdwLXRvZ2dsZUJ1dHRvbiwgcC10b2dnbGVidXR0b24sIHAtdG9nZ2xlLWJ1dHRvbicsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBpbXBvcnRzOiBbUmlwcGxlLCBBdXRvRm9jdXMsIENvbW1vbk1vZHVsZSwgU2hhcmVkTW9kdWxlXSxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBwUmlwcGxlXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cImN4KCdyb290JylcIlxuICAgICAgICAgICAgW2NsYXNzXT1cInN0eWxlQ2xhc3NcIlxuICAgICAgICAgICAgW3RhYmluZGV4XT1cInRhYmluZGV4XCJcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlKCRldmVudClcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImFyaWFMYWJlbGxlZEJ5XCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtcHJlc3NlZF09XCJjaGVja2VkXCJcbiAgICAgICAgICAgIFthdHRyLmRhdGEtcC1jaGVja2VkXT1cImFjdGl2ZVwiXG4gICAgICAgICAgICBbYXR0ci5kYXRhLXAtZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICA+XG4gICAgICAgICAgICA8c3BhbiBbbmdDbGFzc109XCJjeCgnY29udGVudCcpXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImNvbnRlbnRUZW1wbGF0ZTsgY29udGV4dDogeyAkaW1wbGljaXQ6IGNoZWNrZWQgfVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIEBpZiAoIWNvbnRlbnRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBAaWYgKCFpY29uVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEBpZiAob25JY29uIHx8IG9mZkljb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2xhc3NdPVwiY2hlY2tlZCA/IHRoaXMub25JY29uIDogdGhpcy5vZmZJY29uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3AtdG9nZ2xlYnV0dG9uLWljb24nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3AtdG9nZ2xlYnV0dG9uLWljb24tbGVmdCc6IGljb25Qb3MgPT09ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwLXRvZ2dsZWJ1dHRvbi1pY29uLXJpZ2h0JzogaWNvblBvcyA9PT0gJ3JpZ2h0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1wYy1zZWN0aW9uXT1cIidpY29uJ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBAZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiaWNvblRlbXBsYXRlOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogY2hlY2tlZCB9XCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgQGlmIChvbkxhYmVsIHx8IG9mZkxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBbbmdDbGFzc109XCJjeCgnbGFiZWwnKVwiIFthdHRyLmRhdGEtcGMtc2VjdGlvbl09XCInbGFiZWwnXCI+e3sgY2hlY2tlZCA/IChoYXNPbkxhYmVsID8gb25MYWJlbCA6ICcnKSA6IGhhc09mZkxhYmVsID8gb2ZmTGFiZWwgOiAnJyB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgYCxcbiAgICBwcm92aWRlcnM6IFtUT0dHTEVCVVRUT05fVkFMVUVfQUNDRVNTT1IsIFRvZ2dsZUJ1dHRvblN0eWxlXSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBUb2dnbGVCdXR0b24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIExhYmVsIGZvciB0aGUgb24gc3RhdGUuXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KCkgb25MYWJlbDogc3RyaW5nID0gJ1llcyc7XG4gICAgLyoqXG4gICAgICogTGFiZWwgZm9yIHRoZSBvZmYgc3RhdGUuXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KCkgb2ZmTGFiZWw6IHN0cmluZyA9ICdObyc7XG4gICAgLyoqXG4gICAgICogSWNvbiBmb3IgdGhlIG9uIHN0YXRlLlxuICAgICAqIEBncm91cCBQcm9wc1xuICAgICAqL1xuICAgIEBJbnB1dCgpIG9uSWNvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIEljb24gZm9yIHRoZSBvZmYgc3RhdGUuXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KCkgb2ZmSWNvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgYSBzdHJpbmcgdGhhdCBsYWJlbHMgdGhlIGlucHV0IGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgICAqIEBncm91cCBQcm9wc1xuICAgICAqL1xuICAgIEBJbnB1dCgpIGFyaWFMYWJlbDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaGVzIHJlbGF0aW9uc2hpcHMgYmV0d2VlbiB0aGUgY29tcG9uZW50IGFuZCBsYWJlbChzKSB3aGVyZSBpdHMgdmFsdWUgc2hvdWxkIGJlIG9uZSBvciBtb3JlIGVsZW1lbnQgSURzLlxuICAgICAqIEBncm91cCBQcm9wc1xuICAgICAqL1xuICAgIEBJbnB1dCgpIGFyaWFMYWJlbGxlZEJ5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogV2hlbiBwcmVzZW50LCBpdCBzcGVjaWZpZXMgdGhhdCB0aGUgZWxlbWVudCBzaG91bGQgYmUgZGlzYWJsZWQuXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pIGRpc2FibGVkOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIElubGluZSBzdHlsZSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBAZ3JvdXAgUHJvcHNcbiAgICAgKi9cbiAgICBASW5wdXQoKSBzdHlsZTogYW55O1xuICAgIC8qKlxuICAgICAqIFN0eWxlIGNsYXNzIG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBncm91cCBQcm9wc1xuICAgICAqL1xuICAgIEBJbnB1dCgpIHN0eWxlQ2xhc3M6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgZ2V0IGhvc3RDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGVDbGFzcyB8fCAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWRlbnRpZmllciBvZiB0aGUgZm9jdXMgaW5wdXQgdG8gbWF0Y2ggYSBsYWJlbCBkZWZpbmVkIGZvciB0aGUgY29tcG9uZW50LlxuICAgICAqIEBncm91cCBQcm9wc1xuICAgICAqL1xuICAgIEBJbnB1dCgpIGlucHV0SWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBJbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0YWJiaW5nIG9yZGVyLlxuICAgICAqIEBncm91cCBQcm9wc1xuICAgICAqL1xuICAgIEBJbnB1dCh7IHRyYW5zZm9ybTogbnVtYmVyQXR0cmlidXRlIH0pIHRhYmluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQgPSAwO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIHNpemUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAZ3JvdXAgUHJvcHNcbiAgICAgKi9cbiAgICBASW5wdXQoKSBzaXplOiAnbGFyZ2UnIHwgJ3NtYWxsJztcbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiBvZiB0aGUgaWNvbi5cbiAgICAgKiBAZ3JvdXAgUHJvcHNcbiAgICAgKi9cbiAgICBASW5wdXQoKSBpY29uUG9zOiAnbGVmdCcgfCAncmlnaHQnID0gJ2xlZnQnO1xuICAgIC8qKlxuICAgICAqIFdoZW4gcHJlc2VudCwgaXQgc3BlY2lmaWVzIHRoYXQgdGhlIGNvbXBvbmVudCBzaG91bGQgYXV0b21hdGljYWxseSBnZXQgZm9jdXMgb24gbG9hZC5cbiAgICAgKiBAZ3JvdXAgUHJvcHNcbiAgICAgKi9cbiAgICBASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSkgYXV0b2ZvY3VzOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgc2VsZWN0aW9uIGNhbiBub3QgYmUgY2xlYXJlZC5cbiAgICAgKiBAZ3JvdXAgUHJvcHNcbiAgICAgKi9cbiAgICBASW5wdXQoKSBhbGxvd0VtcHR5OiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRvIGludm9rZSBvbiB2YWx1ZSBjaGFuZ2UuXG4gICAgICogQHBhcmFtIHtUb2dnbGVCdXR0b25DaGFuZ2VFdmVudH0gZXZlbnQgLSBDdXN0b20gY2hhbmdlIGV2ZW50LlxuICAgICAqIEBncm91cCBFbWl0c1xuICAgICAqL1xuICAgIEBPdXRwdXQoKSBvbkNoYW5nZTogRXZlbnRFbWl0dGVyPFRvZ2dsZUJ1dHRvbkNoYW5nZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8VG9nZ2xlQnV0dG9uQ2hhbmdlRXZlbnQ+KCk7XG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGljb24gdGVtcGxhdGUuXG4gICAgICogQGdyb3VwIFRlbXBsYXRlc1xuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2ljb24nKSBpY29uVGVtcGxhdGU6IE51bGxhYmxlPFRlbXBsYXRlUmVmPGFueT4+O1xuICAgIC8qKlxuICAgICAqIEN1c3RvbSBjb250ZW50IHRlbXBsYXRlLlxuICAgICAqIEBncm91cCBUZW1wbGF0ZXNcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdjb250ZW50JykgY29udGVudFRlbXBsYXRlOiBOdWxsYWJsZTxUZW1wbGF0ZVJlZjxhbnk+PjtcblxuICAgIGNoZWNrZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIG9uTW9kZWxDaGFuZ2U6IEZ1bmN0aW9uID0gKCkgPT4ge307XG5cbiAgICBvbk1vZGVsVG91Y2hlZDogRnVuY3Rpb24gPSAoKSA9PiB7fTtcblxuICAgIF9jb21wb25lbnRTdHlsZSA9IGluamVjdChUb2dnbGVCdXR0b25TdHlsZSk7XG5cbiAgICB0b2dnbGUoZXZlbnQ6IEV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiAhKHRoaXMuYWxsb3dFbXB0eSA9PT0gZmFsc2UgJiYgdGhpcy5jaGVja2VkKSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSh0aGlzLmNoZWNrZWQpO1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCgpO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBjaGVja2VkOiB0aGlzLmNoZWNrZWRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25LZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQuY29kZSkge1xuICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnU3BhY2UnOlxuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25CbHVyKCkge1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkKCk7XG4gICAgfVxuXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZSA9IGZuO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLm9uTW9kZWxUb3VjaGVkID0gZm47XG4gICAgfVxuXG4gICAgc2V0RGlzYWJsZWRTdGF0ZSh2YWw6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHZhbDtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICBnZXQgaGFzT25MYWJlbCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm9uTGFiZWwgJiYgdGhpcy5vbkxhYmVsLmxlbmd0aCA+IDApIGFzIGJvb2xlYW47XG4gICAgfVxuXG4gICAgZ2V0IGhhc09mZkxhYmVsKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKHRoaXMub25MYWJlbCAmJiB0aGlzLm9uTGFiZWwubGVuZ3RoID4gMCkgYXMgYm9vbGVhbjtcbiAgICB9XG5cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja2VkID09PSB0cnVlO1xuICAgIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbVG9nZ2xlQnV0dG9uLCBTaGFyZWRNb2R1bGVdLFxuICAgIGV4cG9ydHM6IFtUb2dnbGVCdXR0b24sIFNoYXJlZE1vZHVsZV1cbn0pXG5leHBvcnQgY2xhc3MgVG9nZ2xlQnV0dG9uTW9kdWxlIHt9XG4iXX0=