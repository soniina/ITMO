import { CommonModule, isPlatformBrowser } from '@angular/common';
import { ChangeDetectionStrategy, Component, ContentChild, inject, Input, NgModule, ViewEncapsulation } from '@angular/core';
import { SharedModule } from 'primeng/api';
import { BaseComponent } from 'primeng/basecomponent';
import { ImageCompareStyle } from './style/imagecomparestyle';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
const _c0 = ["left"];
const _c1 = ["right"];
function ImageCompare_0_ng_template_0_Template(rf, ctx) { }
function ImageCompare_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, ImageCompare_0_ng_template_0_Template, 0, 0, "ng-template");
} }
function ImageCompare_1_ng_template_0_Template(rf, ctx) { }
function ImageCompare_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, ImageCompare_1_ng_template_0_Template, 0, 0, "ng-template");
} }
/**
 * Compare two images side by side with a slider.
 * @group Components
 */
export class ImageCompare extends BaseComponent {
    isRTL = false;
    /**
     * Index of the element in tabbing order.
     * @defaultValue 0
     * @group Props
     */
    tabindex;
    /**
     * Defines a string value that labels an interactive element.
     * @group Props
     */
    ariaLabelledby;
    /**
     * Identifier of the underlying input element.
     * @group Props
     */
    ariaLabel;
    /**
     * Template for the left side.
     * @group Templates
     */
    leftTemplate;
    /**
     * Template for the right side.
     * @group Templates
     */
    rightTemplate;
    _componentStyle = inject(ImageCompareStyle);
    mutationObserver;
    ngOnInit() {
        super.ngOnInit();
        this.updateDirection();
        this.observeDirectionChanges();
    }
    onSlide(event) {
        const value = event.target.value;
        const image = event.target.previousElementSibling;
        if (this.isRTL) {
            image.style.clipPath = `polygon(${100 - value}% 0, 100% 0, 100% 100%, ${100 - value}% 100%)`;
        }
        else {
            image.style.clipPath = `polygon(0 0, ${value}% 0, ${value}% 100%, 0 100%)`;
        }
    }
    updateDirection() {
        this.isRTL = !!this.el.nativeElement.closest('[dir="rtl"]');
    }
    observeDirectionChanges() {
        if (isPlatformBrowser(this.platformId)) {
            const targetNode = document?.documentElement;
            const config = { attributes: true, attributeFilter: ['dir'] };
            this.mutationObserver = new MutationObserver(() => {
                this.updateDirection();
            });
            this.mutationObserver.observe(targetNode, config);
        }
    }
    ngOnDestroy() {
        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
        }
        super.ngOnDestroy();
    }
    static ɵfac = /*@__PURE__*/ (() => { let ɵImageCompare_BaseFactory; return function ImageCompare_Factory(__ngFactoryType__) { return (ɵImageCompare_BaseFactory || (ɵImageCompare_BaseFactory = i0.ɵɵgetInheritedFactory(ImageCompare)))(__ngFactoryType__ || ImageCompare); }; })();
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ImageCompare, selectors: [["p-imageCompare"], ["p-imagecompare"], ["p-image-compare"]], contentQueries: function ImageCompare_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
            i0.ɵɵcontentQuery(dirIndex, _c0, 5);
            i0.ɵɵcontentQuery(dirIndex, _c1, 5);
        } if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.leftTemplate = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rightTemplate = _t.first);
        } }, hostAttrs: [1, "p-imagecompare"], hostVars: 3, hostBindings: function ImageCompare_HostBindings(rf, ctx) { if (rf & 2) {
            i0.ɵɵattribute("tabindex", ctx.tabindex)("aria-labelledby", ctx.ariaLabelledby)("aria-label", ctx.ariaLabel);
        } }, inputs: { tabindex: "tabindex", ariaLabelledby: "ariaLabelledby", ariaLabel: "ariaLabel" }, standalone: true, features: [i0.ɵɵProvidersFeature([ImageCompareStyle]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature], decls: 3, vars: 4, consts: [[4, "ngTemplateOutlet"], ["type", "range", "min", "0", "max", "100", "value", "50", 3, "input"]], template: function ImageCompare_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵtemplate(0, ImageCompare_0_Template, 1, 0, null, 0)(1, ImageCompare_1_Template, 1, 0, null, 0);
            i0.ɵɵelementStart(2, "input", 1);
            i0.ɵɵlistener("input", function ImageCompare_Template_input_input_2_listener($event) { return ctx.onSlide($event); });
            i0.ɵɵelementEnd();
        } if (rf & 2) {
            i0.ɵɵproperty("ngTemplateOutlet", ctx.leftTemplate);
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngTemplateOutlet", ctx.rightTemplate);
            i0.ɵɵadvance();
            i0.ɵɵclassMap(ctx.cx("slider"));
        } }, dependencies: [CommonModule, i1.NgTemplateOutlet, SharedModule], encapsulation: 2, changeDetection: 0 });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ImageCompare, [{
        type: Component,
        args: [{
                selector: 'p-imageCompare, p-imagecompare, p-image-compare',
                standalone: true,
                imports: [CommonModule, SharedModule],
                template: `
        <ng-template *ngTemplateOutlet="leftTemplate"></ng-template>
        <ng-template *ngTemplateOutlet="rightTemplate"></ng-template>

        <input type="range" min="0" max="100" value="50" (input)="onSlide($event)" [class]="cx('slider')" />
    `,
                host: {
                    class: 'p-imagecompare',
                    '[attr.tabindex]': 'tabindex',
                    '[attr.aria-labelledby]': 'ariaLabelledby',
                    '[attr.aria-label]': 'ariaLabel'
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                providers: [ImageCompareStyle]
            }]
    }], null, { tabindex: [{
            type: Input
        }], ariaLabelledby: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], leftTemplate: [{
            type: ContentChild,
            args: ['left']
        }], rightTemplate: [{
            type: ContentChild,
            args: ['right']
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(ImageCompare, { className: "ImageCompare" }); })();
export class ImageCompareModule {
    static ɵfac = function ImageCompareModule_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || ImageCompareModule)(); };
    static ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: ImageCompareModule });
    static ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [ImageCompare, SharedModule, SharedModule] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ImageCompareModule, [{
        type: NgModule,
        args: [{
                imports: [ImageCompare, SharedModule],
                exports: [ImageCompare, SharedModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(ImageCompareModule, { imports: [ImageCompare, SharedModule], exports: [ImageCompare, SharedModule] }); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1hZ2Vjb21wYXJlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2ltYWdlY29tcGFyZS9pbWFnZWNvbXBhcmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2xFLE9BQU8sRUFBb0IsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBZSxpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM1SixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQzs7Ozs7OztJQVd0RCw0RUFBOEM7Ozs7SUFDOUMsNEVBQStDOztBQVZ2RDs7O0dBR0c7QUFxQkgsTUFBTSxPQUFPLFlBQWEsU0FBUSxhQUFhO0lBQzNDLEtBQUssR0FBWSxLQUFLLENBQUM7SUFFdkI7Ozs7T0FJRztJQUNNLFFBQVEsQ0FBcUI7SUFDdEM7OztPQUdHO0lBQ00sY0FBYyxDQUFxQjtJQUM1Qzs7O09BR0c7SUFDTSxTQUFTLENBQXFCO0lBRXZDOzs7T0FHRztJQUNtQixZQUFZLENBQW1CO0lBRXJEOzs7T0FHRztJQUNvQixhQUFhLENBQW1CO0lBRXZELGVBQWUsR0FBRyxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUU1QyxnQkFBZ0IsQ0FBbUI7SUFFbkMsUUFBUTtRQUNKLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNqQixJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLHVCQUF1QixFQUFFLENBQUM7SUFDbkMsQ0FBQztJQUVELE9BQU8sQ0FBQyxLQUFLO1FBQ1QsTUFBTSxLQUFLLEdBQUcsS0FBSyxD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Z0JBQ04sT0FBTyxFQUFFLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQztnQkFDckMsT0FBTyxFQUFFLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQzthQUN4Qzs7d0ZBQ1ksa0JBQWtCLGNBbkZsQixZQUFZLEVBZ0ZHLFlBQVksYUFoRjNCLFlBQVksRUFpRkcsWUFBWSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbW1vbk1vZHVsZSwgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgQ29udGVudENoaWxkLCBpbmplY3QsIElucHV0LCBOZ01vZHVsZSwgVGVtcGxhdGVSZWYsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTaGFyZWRNb2R1bGUgfSBmcm9tICdwcmltZW5nL2FwaSc7XG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAncHJpbWVuZy9iYXNlY29tcG9uZW50JztcbmltcG9ydCB7IEltYWdlQ29tcGFyZVN0eWxlIH0gZnJvbSAnLi9zdHlsZS9pbWFnZWNvbXBhcmVzdHlsZSc7XG5cbi8qKlxuICogQ29tcGFyZSB0d28gaW1hZ2VzIHNpZGUgYnkgc2lkZSB3aXRoIGEgc2xpZGVyLlxuICogQGdyb3VwIENvbXBvbmVudHNcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdwLWltYWdlQ29tcGFyZSwgcC1pbWFnZWNvbXBhcmUsIHAtaW1hZ2UtY29tcGFyZScsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBTaGFyZWRNb2R1bGVdLFxuICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdUZW1wbGF0ZU91dGxldD1cImxlZnRUZW1wbGF0ZVwiPjwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdUZW1wbGF0ZU91dGxldD1cInJpZ2h0VGVtcGxhdGVcIj48L25nLXRlbXBsYXRlPlxuXG4gICAgICAgIDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBtaW49XCIwXCIgbWF4PVwiMTAwXCIgdmFsdWU9XCI1MFwiIChpbnB1dCk9XCJvblNsaWRlKCRldmVudClcIiBbY2xhc3NdPVwiY3goJ3NsaWRlcicpXCIgLz5cbiAgICBgLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgY2xhc3M6ICdwLWltYWdlY29tcGFyZScsXG4gICAgICAgICdbYXR0ci50YWJpbmRleF0nOiAndGFiaW5kZXgnLFxuICAgICAgICAnW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XSc6ICdhcmlhTGFiZWxsZWRieScsXG4gICAgICAgICdbYXR0ci5hcmlhLWxhYmVsXSc6ICdhcmlhTGFiZWwnXG4gICAgfSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIHByb3ZpZGVyczogW0ltYWdlQ29tcGFyZVN0eWxlXVxufSlcbmV4cG9ydCBjbGFzcyBJbWFnZUNvbXBhcmUgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG4gICAgaXNSVEw6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHRoZSBlbGVtZW50IGluIHRhYmJpbmcgb3JkZXIuXG4gICAgICogQGRlZmF1bHRWYWx1ZSAwXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KCkgdGFiaW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgc3RyaW5nIHZhbHVlIHRoYXQgbGFiZWxzIGFuIGludGVyYWN0aXZlIGVsZW1lbnQuXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KCkgYXJpYUxhYmVsbGVkYnk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVyIG9mIHRoZSB1bmRlcmx5aW5nIGlucHV0IGVsZW1lbnQuXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KCkgYXJpYUxhYmVsOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUZW1wbGF0ZSBmb3IgdGhlIGxlZnQgc2lkZS5cbiAgICAgKiBAZ3JvdXAgVGVtcGxhdGVzXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnbGVmdCcpIGxlZnRUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIFRlbXBsYXRlIGZvciB0aGUgcmlnaHQgc2lkZS5cbiAgICAgKiBAZ3JvdXAgVGVtcGxhdGVzXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgncmlnaHQnKSByaWdodFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgX2NvbXBvbmVudFN0eWxlID0gaW5qZWN0KEltYWdlQ29tcGFyZVN0eWxlKTtcblxuICAgIG11dGF0aW9uT2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXI7XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlRGlyZWN0aW9uQ2hhbmdlcygpO1xuICAgIH1cblxuICAgIG9uU2xpZGUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgIGNvbnN0IGltYWdlID0gZXZlbnQudGFyZ2V0LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNSVEwpIHtcbiAgICAgICAgICAgIGltYWdlLnN0eWxlLmNsaXBQYXRoID0gYHBvbHlnb24oJHsxMDAgLSB2YWx1ZX0lIDAsIDEwMCUgMCwgMTAwJSAxMDAlLCAkezEwMCAtIHZhbHVlfSUgMTAwJSlgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW1hZ2Uuc3R5bGUuY2xpcFBhdGggPSBgcG9seWdvbigwIDAsICR7dmFsdWV9JSAwLCAke3ZhbHVlfSUgMTAwJSwgMCAxMDAlKWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVEaXJlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaXNSVEwgPSAhIXRoaXMuZWwubmF0aXZlRWxlbWVudC5jbG9zZXN0KCdbZGlyPVwicnRsXCJdJyk7XG4gICAgfVxuXG4gICAgb2JzZXJ2ZURpcmVjdGlvbkNoYW5nZXMoKSB7XG4gICAgICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gZG9jdW1lbnQ/LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHsgYXR0cmlidXRlczogdHJ1ZSwgYXR0cmlidXRlRmlsdGVyOiBbJ2RpciddIH07XG5cbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURpcmVjdGlvbigpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRhcmdldE5vZGUsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG4gICAgfVxufVxuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtJbWFnZUNvbXBhcmUsIFNoYXJlZE1vZHVsZV0sXG4gICAgZXhwb3J0czogW0ltYWdlQ29tcGFyZSwgU2hhcmVkTW9kdWxlXVxufSlcbmV4cG9ydCBjbGFzcyBJbWFnZUNvbXBhcmVNb2R1bGUge31cbiJdfQ==